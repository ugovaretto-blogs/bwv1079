---
layout: post
title: R-value references and type deduction
date: 2013-11-20 14:57:38.000000000 +08:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- C++
- c++11
tags:
- c++
- perfect forwarding
- rvalue references
- std::forward
- std::move
meta:
  _edit_last: '58138826'
  _publicize_pending: '1'
author:
  login: ugovaretto
  email: ugovaretto@gmail.com
  display_name: ugovaretto
  first_name: ''
  last_name: ''
permalink: "/2013/11/20/r-value-references-and-type-deduction/"
---
<p>While experimenting with <em>C++11</em> perfect forwarding (i.e. all arguments to a function are forwarded in their actual current form to another function maintaining all the original qualifiers and types) I ended up with the following code that compiles fine:<br />
[code lang="cpp" light="true"]<br />
template &lt; typename T &gt;<br />
void Forward(T&amp;&amp; ) {<br />
...<br />
}<br />
...<br />
int i = int();<br />
Forward(i);<br />
[/code]<br />
and the following code that does not<br />
[code lang="cpp" light="true"]<br />
void Forward(int&amp;&amp; ) {<br />
...<br />
}<br />
...<br />
int i = int();<br />
Forward(i);<br />
[/code]</p>
<p>The reported error is:<br />
[code light="true"]<br />
: error: no matching function for call to 'Forward'<br />
    Forward(i);<br />
    ^~~~~~~<br />
[/code]</p>
<p>To understand what is going on let's modify the code like this:<br />
[code lang="cpp" light="true"]<br />
template &lt; typename T &gt;<br />
void Forward(T&amp;&amp; v) {<br />
  v = T(2);<br />
}<br />
...<br />
int i = 1;<br />
Forward(i);<br />
[/code]</p>
<p>This time the error we get when compiling is:<br />
[code light="true"]<br />
error: functional-style cast from rvalue to reference type 'int &amp;'<br />
    v = T(2);<br />
        ^~~&lt;/pre&gt;<br />
[/code]</p>
<p>it is telling us the <code>T</code> type is an <code>int&amp;</code> and not simply an <code>int</code>.</p>
<p>So how come an <code>int&amp;</code> declaration got transformed into an <code>int&amp;</code> reference ?</p>
<p>That is because <code>i</code> is an lvalue and when passing an lvalue to an rvalue reference the lvalue is passed by reference.</p>
<p>The template version works because, through template type deduction rules, the type <code>T (int)</code> is automatically transformed to <code>T&amp; (int&amp;)</code> and <code>T&amp; &amp;&amp;</code> automatically collapses to <code>T&amp;</code>.</p>
<p>When not using templates there is no <code>T</code> ⇒ <code>T&amp;</code> conversion taking place and therefore the function does not receive a reference to an lvalue but an actual lvalue instead and it does complain that the received type is not valid.</p>
<p>The template deduction rules are crafted this way to keep the original type information when passing values to rvalue reference parameters i.e.:</p>
<ul>
<li>an lvalue reference is mapped to an lvalue reference</li>
<li>an rvalue is mapped to an rvalue</li>
</ul>
<p>Keeping the original type information intact is what allows parameters received as rvalue references to be forwarded to callable objects (functions, methods, function objects) through the <code>std::forward</code> function; for a sample use of this feature checkout e.g. note 4 on page 571 of the ISO/IEC 14882:2011 standard where the function call wrapper interface is explained:</p>
<blockquote><p>A forwarding call wrapper is a call wrapper that can be called with an arbitrary argument list and delivers the arguments to the wrapped callable object as references. This forwarding step shall ensure that rvalue arguments are delivered as rvalue-references and lvalue arguments are delivered as lvalue-references. [Note: In a typical implementation forwarding call wrappers have an overloaded function call operator of the form</p>
<pre>
template
R operator()(UnBoundArgs&amp;&amp;... unbound_args) cv-qual;
</pre>
<p>—end note ]</p></blockquote>
