---
layout: post
title: Move forward
date: 2013-11-20 16:09:24.000000000 +08:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- C++
- c++11
tags:
- r-value references
meta:
  _edit_last: '58138826'
  _publicize_pending: '1'
author:
  login: ugovaretto
  email: ugovaretto@gmail.com
  display_name: ugovaretto
  first_name: ''
  last_name: ''
permalink: "/2013/11/20/move-forward/"
---
<p><em>C++11</em> introduces the concept of <em>r-value reference.</em></p>
<p>R-value references allow you to modify a temporary object and are used  to e.g. implement move semantics to "move" content from a source temporary object to a target object while avoiding unnecessary copies.</p>
<p>Such concept also requires an additional set of facilities to be implemented to properly manage parameter forwarding and move operations.</p>
<p>Specifically:</p>
<ul>
<li>when you want to explicitly ask for an object to be "moved" you call the <em>std::move</em> function;</li>
<li>when you want to forward parameters received by a function to another function preserving their type you call <em>std::forward</em></li>
</ul>
<p><em>std::move</em> transforms any reference type <em>T&amp;</em> into an r-value reference <em>T&amp;&amp;</em>.</p>
<p><em>std::forward</em> returns an l-value reference if the input type is an l-value reference type and an r-value reference if the input value is not an l-value reference.</p>
<p>The use of <em>std::move</em> is straightforward: use it whenever you want to force an object to be moved by passing it as an r-value reference to whatever callable entity or assignment operator you are invoking.</p>
<p>To understand why <em>std::forward</em> is required consider the following:</p>
<ol>
<li>an r-value reference is a reference to an unnamed object (array elements are not considered unnamed because they are accessed through a named value);</li>
<li>in cases where you have a function that accepts an r-value reference and such function wants then to call another function passing to it the received value as an r-value reference you have a problem because the value received as an r-value reference now has a name and it is not an r-value reference any more, see below</li>
</ol>
<p>[code lang="cpp" light="true"]<br />
template &lt; typename T &gt;<br />
void bar(T&amp;&amp; i) {...}</p>
<p>template &lt; typename T &gt;<br />
void foo(T&amp;&amp; p) { //receive an r-value reference<br />
    //p has a name therefore it is not an r-value reference<br />
    //pass an l-value reference to bar<br />
    bar(p);<br />
}</p>
<p>foo(2); //call foo with and r-value reference to &quot;2&quot;<br />
[/code]</p>
<p>The function <em>foo</em> receives the parameter <em>p</em> as an r-value reference, but now <em>p</em> is the name assigned to the received value and therefore, within the body of <em>foo</em>, <em>p</em> is not an r-value reference any more but simply an l-value, so the <em>bar</em> function is now called with an l-value reference instead of an r-value reference, i.e. we are calling <em>bar</em> with a type different from the type received by <em>foo</em>.</p>
<p>In order to call the <em>bar</em> function with the same type as received by <em>foo</em> you need to</p>
<ol>
<li>check the type of <em>p</em> and</li>
<li>cast to <em>T&amp;</em> if p is an l-value reference and <em>T&amp;&amp;</em> if <em>p</em> is not an l-value reference</li>
</ol>
<p>So, let's implement a version of <em>std::forward</em> that does what described above:</p>
<p>[code lang="cpp" light="true"]<br />
//T&amp; specialization<br />
template &lt; typename T &gt;<br />
T&amp;&amp; forward(T&amp; v) {<br />
    return static_cast&lt;T&amp;&amp;&gt;(v);<br />
}</p>
<p>//T&amp;&amp; specialization<br />
template &lt; typename T &gt;<br />
T&amp;&amp; forward(T&amp;&amp; v) {<br />
    return static_cast&lt;T&amp;&amp;&gt;(v);<br />
}</p>
<p>//works if called as forward(...)<br />
//does not work when forwarding a reference: forward&lt;int&amp;&gt;(...)<br />
[/code]</p>
<p>All that <em>forward</em> does internally is to perform a <em>static_cast&lt;T&amp;&amp;&gt;(...).</em></p>
<p>The return type is always an r-value reference type which acts as a generic reference i.e. something that becomes either an l-value or an r-value reference after specialization and type deduction occur.</p>
<p>The reason for which forward can return the right type by returning a templated r-value reference type is because of template type deduction rules, discussed in <a href="http://bwv1079.wordpress.com/2013/11/20/r-value-references-and-type-deduction">this post</a>.</p>
<p>Basically:</p>
<ul>
<li><em>Type &amp;</em> (l-value ref) → <em>T&amp;&amp;</em> → <em>Type&amp; &amp;&amp;</em> → <em>Type&amp;</em></li>
<li>T<em>ype &amp;&amp;</em> (r-value ref or value) →  <em>T&amp;&amp;</em> → <em>Type&amp;&amp;</em> or <em>Type&amp;&amp; &amp;&amp;</em> → <em>Type &amp;&amp;</em></li>
</ul>
<p>Where T can also be qualified as <em>const</em> and/or <em>volatile</em> i.e. given a type <em>U</em>, <em>Type =  U</em> or <em>const U</em> or <em>volatile U</em> or <em>const volatile U</em>.</p>
<p>This means that by returning a <em>T&amp;&amp;</em> type you are actually returning a generic reference which is defined as <em>T&amp;</em> or <em>T&amp;&amp;</em> at compile time depending on the type <em>T</em>.</p>
<p>Now, this version works if you do not specialize it with a reference type, to make it work with reference types you need to remove the reference from the type passed to the function:</p>
<p>[code lang="cpp" light="true"]<br />
#include &lt;type_traits&gt;</p>
<p>template &lt; typename T &gt;<br />
T&amp;&amp; forward(typename std::remove_reference::type&amp; v) {<br />
    return static_cast&lt;T&amp;&amp;&gt;(v);<br />
}</p>
<p>template &lt; typename T &gt;<br />
T&amp;&amp; forward(typename std::remove_reference::type&amp;&amp; v) {<br />
    return static_cast&lt;T&amp;&amp;&gt;(v);<br />
}</p>
<p>//it now works with forward&lt;int&amp;&gt;()<br />
[/code]</p>
<p>now we have an implementation that works as the standard <em>std::forward</em> library function.</p>
<p>Well almost...</p>
<p>[code lang="cpp" light="true"]<br />
//this compiles!<br />
int&amp; r = forward&lt;int&amp;&gt;(2);<br />
//r is a non-const reference to a temporary object<br />
[/code]</p>
<p>the code above does create an l-value reference pointing to a temporary object!</p>
<p>To catch r-value reference to l-value reference conversion attempts you can use a <em>static_assert</em> in the function body:</p>
<p>[code lang="cpp" light="true"]<br />
template &lt; typename T &gt;<br />
T&amp;&amp; forward(typename std::remove_reference::type&amp;&amp; v) {<br />
    static_assert(!std::is_lvalue_reference&lt;T&gt;::value,...);<br />
    return static_cast&lt;T&amp;&amp;&gt;(v);<br />
}<br />
[/code]</p>
<p>Now the implementation is almost exactly the same as the one found in most STL implementations where almost = missing <em>constexpr</em> and <em>noexcept</em>.</p>
<p>With the current implementation:</p>
<ul>
<li>a value is forwarded as an r-value reference to a temporary object</li>
<li>an r-value reference is forwarded as an r-value reference</li>
<li>an l-value reference is forwarded as an l-value reference</li>
</ul>
<p>What you cannot do is this:</p>
<p>[code lang="cpp" light="true"]</p>
<p>template &lt; typename T &gt;<br />
constexpr int C(T&amp;&amp; ) { return 1; }</p>
<p>template &lt; typename T &gt;<br />
constexpr int CallC(T&amp;&amp; v) { return C(forward&lt; T &gt;(v)); }</p>
<p>[/code]</p>
<p>That is because our implementation of <em>forward</em> is not declared as <em>constexpr</em>.</p>
<p>The final standard conforming implementation of <em>forward</em> is then:</p>
<p>[code lang="cpp" light="true"]<br />
template &lt; typename T &gt;<br />
constexpr T&amp;&amp;<br />
forward(typename std::remove_reference::type&amp; p) noexcept {<br />
    return static_cast&lt;T&amp;&amp;&gt;(p);<br />
}</p>
<p>template<br />
constexpr T&amp;&amp;<br />
forward(typename std::remove_reference::type&amp;&amp; p) noexcept {<br />
    static_assert(<br />
        !std::is_lvalue_reference::value,<br />
        &quot;ERROR: R-value reference to L-value reference cast&quot;);<br />
    return static_cast&lt;T&amp;&amp;&gt;(p);<br />
}<br />
[/code]</p>
<p>And here is a small program to test different calling patterns.</p>
<p>[code lang="cpp" light="true"]<br />
#include &lt;iostream&gt;<br />
#include &lt;utility&gt; //move and forward<br />
//------------------------------------------------------------------------------<br />
//overloaded functions called by Forward function<br />
void Overfoo(int&amp; arg) { std::cout &lt;&lt; &quot;L-value\n&quot;; }<br />
void Overfoo(int const &amp;arg) { std::cout &lt;&lt; &quot;const L-value\n&quot;; }<br />
void Overfoo(int&amp;&amp; arg) { std::cout &lt;&lt; &quot;R-value\n&quot;; }<br />
//note: returning a const r-value reference is useful to forbid code to use<br />
//temporary values returned by functions:<br />
//foo(const int&amp; ): accepts temporary instances of T returned by functions<br />
//as xvalues<br />
void Overfoo(const int&amp;&amp; arg) { std::cout &lt;&lt; &quot;const R-value\n&quot;; }<br />
void Overfoo(volatile const int &amp;arg ) {<br />
    std::cout &lt;&lt; &quot;volatile const L-value\n&quot;;<br />
}<br />
void Overfoo(volatile int &amp;arg) { std::cout &lt;&lt; &quot;volatile L-value\n&quot;; }<br />
void Overfoo(volatile int &amp;&amp; arg) { std::cout &lt;&lt; &quot;volatile R-value\n&quot;; }<br />
void Overfoo(volatile const int &amp;&amp; arg) { std::cout &lt;&lt; &quot;const volatile R-value\n&quot;; }</p>
<p>template &lt; typename T &gt;<br />
void Forward(T&amp;&amp; arg) {<br />
    //note: arg is a local NAMED parameter so it is NEVER of type &amp;&amp;, in order<br />
    //to properly forward it as an r-value reference you need to use the<br />
    //forward function<br />
    std::cout &lt;&lt; &quot;  std::forward -&gt; &quot;;<br />
    Overfoo(std::forward&lt; T &gt;(arg));<br />
    //note: move transforms anything to an R-value<br />
    std::cout &lt;&lt; &quot;  std::move    -&gt; &quot;;<br />
    Overfoo(std::move(arg));<br />
    std::cout &lt;&lt; &quot;               -&gt; &quot;;<br />
    Overfoo(arg);<br />
}</p>
<p>//------------------------------------------------------------------------------<br />
int main() {<br />
    std::cout &lt;&lt; &quot;R-value -&gt;\n&quot;;<br />
    Forward(0);<br />
    std::cout &lt;&lt; &quot;L-value -&gt;\n&quot;;<br />
    int i = 1;<br />
    Forward(i);<br />
    std::cout &lt;&lt; &quot;const L-value -&gt;\n&quot;;<br />
    const int ci = 2;<br />
    Forward(ci);<br />
    std::cout &lt;&lt; &quot;volatile L-value -&gt;\n&quot;;<br />
    volatile int vi = 3;<br />
    Forward(vi);<br />
    std::cout &lt;&lt; &quot;volatile const L-value -&gt;\n&quot;;<br />
    volatile const int cvj = 4;<br />
    Forward(cvj);<br />
    std::cout &lt;&lt; &quot;++i -&gt;\n&quot;;<br />
    Forward(++i);<br />
    std::cout &lt;&lt; &quot;i++ -&gt;\n&quot;;<br />
    Forward(i++);<br />
    return 0;<br />
}<br />
[/code]</p>
<p>If you compile and run this program you'll see from the output that <em>std::forward</em> does in fact forward parameters to <em>Overfoo</em> with the same exact type passed to the <em>Forward</em> function, which is not the case when forwarding parameters without calling <em>std::forward</em> explicitly, this behavior is also known as <em>perfect forwarding</em>.</p>
