---
layout: post
title: C++11 on GPUs
date: 2014-08-27 13:33:00.000000000 +08:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- C++
- c++11
- CUDA
- GPU
- OpenCL
tags: []
meta:
  _edit_last: '58138826'
  geo_public: '0'
  _publicize_job_id: '20991571348'
author:
  login: ugovaretto
  email: ugovaretto@gmail.com
  display_name: ugovaretto
  first_name: ''
  last_name: ''
permalink: "/2014/08/27/c11-on-gpus/"
---
<p>I recently had to check the support of C++11 constructs on compilers that target accelerators such as NVIDIA and AMD GPUs.</p>
<p>One option you have nowadays is to use CLang/LLVM to generate PTX code directly from C++ but this approach introduces another set of issues, which can be addressed only by basically implementing your very own custom compiler or a set of compiler wrappers. For this option to be viable I believe we need to wait for a full implementation of LLVM based compilers supporting the SPIR standard.</p>
<p>In the case of accelerators supporting the OpenCL standard there is no explicit C++11 support at the time of this writing, however the new SYCL standard that specifies a C++11-based language suitable for writing code for massively parallel devices is going to be released soon.</p>
<h2>CUDA</h2>
<p>Up to CUDA 6.0 not only the code targeting the accelerator but even the code targeting the host (CPU) was not allowed to include any C++11 features when compiled with <code>nvcc</code>.</p>
<p>The good news is that as of CUDA 6.5 the entire set of new features introduced in the C++11 standard seems to be supported except for <code>alignas</code>.</p>
<p>Code is available <a title="code" href="https://github.com/ugovaretto/cuda-training/blob/master/src/021_0_cpp11-global-shared-memory.cu">here</a>, you can check for yourself the list of tested features by looking at the comment header and reading through the code.</p>
<p>The set of features that are not conforming with the standard or require special handling is listed below:</p>
<ul>
<li><em>default constructors</em>: <code>__device__</code> prefix required</li>
<li><code>constexpr</code>: does work as a template argument (as e.g. in <code>static_assert</code>); does not work as size of POD array</li>
<li><code>alignas</code>: NOT SUPPORTED</li>
<li><em>attributes</em>: <code>[[attribute]]</code> is parsed correctly and does not result in compilation errors but it cannot (yet?) be used to specify <code>__host__</code> or <code>__device__</code> placement</li>
</ul>
