---
layout: post
title: Constant r-value references
date: 2013-11-20 15:17:15.000000000 +08:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- C++
- c++11
tags:
- c++
- rvalue references
- template deduction
- templates
meta:
  _edit_last: '58138826'
  _publicize_pending: '1'
author:
  login: ugovaretto
  email: ugovaretto@gmail.com
  display_name: ugovaretto
  first_name: ''
  last_name: ''
permalink: "/2013/11/20/constant-r-value-references/"
---
<p>R-value references are a type of reference which supports references to temporary objects such as as e.g. the ones returned from functions.</p>
<p>The main uses of r-value references are:</p>
<ul>
<li>"move" the inner part of an object from a source to a destination instance to avoid copying data from an object that will be destroyed anyway just after the assignment or construction statement is executed</li>
<li>transfer ownership (i.e. the responsibility to delete a wrapped object)</li>
</ul>
<p>So why would anyone want to use a constant r-value reference which prevents the move action to take place ? </p>
<p>Because if you are holding a reference to an object for future use you do not want to assign to it a reference to a temporary object which will disappear just after the assignment operation and there is one case where in order to prevent the assignment of a reference to a temporary object you need to deal with constant r-value references.</p>
<p>Consider the following code:</p>
<p>[code lang="cpp"]<br />
class C {<br />
public:<br />
  C(const B&amp; b, ...) : bref_(b) {...}<br />
  const B&amp; b() const { return bref_; }<br />
...<br />
private:<br />
  const B&amp; bref_;<br />
};</p>
<p>B NewB(...) {<br />
  ...<br />
 return B(...);<br />
}<br />
...<br />
C c(NewB(...)); //invokes C::C(const B&amp;...) constructor<br />
std::cout &lt;&lt; c.b() //BOOOM!<br />
          &lt;&lt; std::endl;<br />
[/code]</p>
<p>A <code>C</code> object is constructed at line 15 but the object <code>C::bref_</code> points to is destroyed just after <code>C</code>construction resulting in a dangling reference stored inside <code>c</code> which in turn results in a run-time error when the following line is executed.</p>
<p>All you have to do to fix this behavior is to report an error when a reference to a temporary object is passed to <code>C</code> constructor. A constructor accepting an r-value reference is the device used to detect when a reference to a temporary object is passed to <code>C</code> constructors.</p>
<p>[code lang="cpp" light="true"]<br />
class C {<br />
public:<br />
  C(const B&amp; b, ...) : bref_(b) {...}<br />
  C(B&amp;&amp; ) { throw std::runtime_error(&quot;Reference to temporary object&quot;); }<br />
  const B&amp; b() const { return bref_; }<br />
...<br />
private:<br />
  const B&amp; bref_;<br />
};<br />
[/code]</p>
<p>The above solution works but it is better to catch the error at compile time by explicitly removing the constructor with a <code>delete</code> statement so that when a temporary object is passed to <code>C</code> constructor the compiler tries to match it with a <code>C::C(B&amp;&amp;)</code> constructor and reports an error.</p>
<p>[code lang="cpp" light="true"]<br />
class C {<br />
public:<br />
  C(const B&amp; b, ...) : bref_(b) {...}<br />
  C(B&amp;&amp;, ...) = delete;<br />
  const B&amp; b() const { return bref_; }<br />
...<br />
private:<br />
  const B&amp; bref_;<br />
};<br />
[/code]</p>
<p>Without <code>delete</code> when a proper constructor is not found the compiler tries the next option that works which in this case is the <code>C::C(const B&amp;)</code> constructor.</p>
<p>It turns out that the above solution has a flaw: if a callable object returns a <strong>constant</strong> type the <code>C::C(const B&amp;,...)</code> constructor is called and we end up with a dangling reference, which is exactly what we wanted to avoid in the first place.</p>
<p>To also cover the case of temporary constant instances we simply have to <code>delete</code> the <code>C::C(const B&amp;&amp;,...)</code> constructor.</p>
<h2>A word on templates</h2>
<p>In case you are dealing with template callable objects, i.e. instead of <code>B&amp;</code> references you have <code>T&amp;</code>references where <code>T</code> is a template parameter, you do not need to add an explicit <code>delete</code> for the <code>const T&amp;&amp;</code> case, this is because when a callable object returns a constant value passed to another callable object the value is already of type <code>const U</code> and it automatically invokes the <code>T&amp;&amp;</code> callable object where <code>T</code> is a constant type of type <code>const U</code>.</p>
<p>To summarize: if you pass an object of type <code>const U</code> to <code>T&amp;&amp;</code> you end up with <code>const U&amp;&amp;</code>, and if you pass it to <code>const T&amp;&amp;</code> you get <code>const const U&amp;&amp;</code>.</p>
<p>As an exercise try to have two versions of the same <strong>template</strong> function with <code>&amp;&amp;</code> and <code>const &amp;&amp;</code>signatures and write code that invokes the <code>const &amp;&amp;</code> version.</p>
<p>In order to verify that removing the <code>T&amp;&amp;</code> version of callable entities is enough to avoid receiving constant temporary instances I did replace the <code>const T&amp;&amp;</code> signatures with <code>T&amp;&amp;</code> in <em>clang 3.3</em> standard library's <code>std::(c)ref</code> functions and got exactly the same results whether I use <code>T&amp;&amp;</code> or <code>const T&amp;&amp;</code>.</p>
<p>Here is the compiler output when compiling code that tries to create a reference to a constant temporary object obtained after changing the <code>std::cref</code> signature to <code>T&amp;&amp;</code>:<br />
[code light="true"]<br />
...<br />
../const-r-value-ref.cpp:49:16: error: call to deleted function 'cref'<br />
    auto ref = std::cref(([] {<br />
               ^~~~~~~~~<br />
/usr/bin/../lib/c++/v1/__functional_base:425:27: note: candidate function [with _Tp = const C] has been explicitly deleted<br />
template &lt;class _Tp&gt; void cref(_Tp&amp;&amp;) = delete;<br />
...<br />
[/code]</p>
<p>pay attention to <strong><code>with _Tp = const C</code></strong> and <strong><code>void cref(_Tp&amp;&amp;) = delete</code></strong>.</p>
<p>What happened is that <code>std::cref</code> got a constant instance and substituted the template parameter with a constant type, so no need to <code>delete</code> the <code>const &amp;&amp;</code> version here because the case is already covered by the <code>&amp;&amp;</code> overload.</p>
<p>No idea why in the standard library they are deleting the <code>const T&amp;&amp;</code>overload, but there probably is a reason, I just do not see it.</p>
<h2>Code</h2>
<p>Feel free to play with the code available <a href="https://github.com/ugovaretto/cpp11-scratch/blob/master/training/const-r-value-ref.cpp">here</a> experimenting with the various compilation options (read the comments).</p>
