---
layout: post
title: Time to time
date: 2014-03-31 14:33:03.000000000 +08:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- C++
- c++11
tags:
- chrono
- time
meta:
  _edit_last: '58138826'
  _publicize_job_id: '22702297006'
  _rest_api_published: '1'
  _rest_api_client_id: "-1"
author:
  login: ugovaretto
  email: ugovaretto@gmail.com
  display_name: ugovaretto
  first_name: ''
  last_name: ''
permalink: "/2014/03/31/time-to-time/"
---
<p>The C++11 standard defines a multi-platform framework to handle time information which can be used to represent full time with date or time differences suitable for timing code execution.</p>
<p>This means no more messing around with <code>clock_gettime()</code>, <code>gettimeofday()</code>, <code>QueryPerformanceCounter()</code> or <code>GetSystemTime()</code>.</p>
<p>With such a framework in place there is no excuse not to time your code any more.</p>
<p>This article does cover the use of C++11 features for computing elapsed time in different scenarios, for complete information on the subject do have a look at the standard specification document (ISO/IEC 14882:2011), chapter 20, sections 10 and 11.</p>
<p>After introducing some basic concepts the various types are analyzed bottom up starting with the basic types and ending with the clock type.</p>
<p>The source code referenced at the end of the post has sample code showing the usage of each of the types described below.</p>
<h2>Basic Concepts</h2>
<p>The time framework is defined in the <code></code> include file.</p>
<p>Three clock types are provided:</p>
<ul>
<li><em>system</em>: wall clock time, matches the system time</li>
<li><em>steady</em>:  guarantees that the returned time value never decreases as physical time increases</li>
<li><em>high resolution</em>: uses the shortest possible tick period, on most systems all clocks use a tick of one nanosecond anyway</li>
</ul>
<p>A point in time is recorded into a <code>time_point</code> instance.</p>
<p>A time span is stored into a <code>duration</code> instance.</p>
<p>A difference between two <code>time_point</code>s returns a <code>duration</code> instance.</p>
<p>A duration represents a number of ticks or periods.</p>
<p>The <em>period</em> represents the length of a tick in seconds and it is encoded with a rational constant.</p>
<p>The rational (numerator over denominator)  constants used to describe a tick period in seconds are represented with the <code>ratio</code> type.</p>
<p>Facilities exist to compare and cast durations and time points as well as to convert to standard C types and print time information.</p>
<p>The steady clock is the preferred choice for timing code execution.</p>
<p>All the needed types and functions other than <code>ratio</code> are declared inside the <code>std::chrono</code> namespace.</p>
<p><code>ratio</code> is declared inside the <code>std</code> namespace.</p>
<h2>Rational constants</h2>
<p>Rational constants i.e. $latex \frac{Numerator}{Denominator}$ are used throughout the <em>chrono</em> framework to specify fractions (1) of seconds. Also a number of predefined constants is available to specify commonly used units such as <em>milli</em> or <em>micro</em>.</p>
<p>Rational constants are declared as <code>ratio</code> type instances.</p>
<p>[code lang="cpp" light="true"]<br />
template &lt; intmax_t N, intmax_t D = 1 &gt;<br />
class ratio {<br />
public:<br />
  typedef ratio&lt; num, den &gt; type;<br />
  static constexpr intmax_t num;<br />
  static constexpr intmax_t den;<br />
};<br />
[/code]</p>
<p>The <code>intmax_t</code> type is the integer type that can represent the biggest possible signed integer.</p>
<p>Numerator and denominator values are defined at compile time as integer numbers.</p>
<p>Arithmetic operations and comparisons can be executed at compile time through the <code>ratio_*</code> functions and types.</p>
<h2>Duration</h2>
<p>The <code>duration</code> type represents a difference between points in time defined as a number of periods (ticks).</p>
<p>From the standard:</p>
<blockquote><p>A duration type measures time between two points in time (time_points). A duration has a representation which holds a count of ticks and a tick period. The tick period is the amount of time which occurs from one tick to the next, <strong>in units of seconds</strong>. It is expressed as a rational constant using the template ratio.</p></blockquote>
<p>The number of ticks is the <em>representation</em> type which can be an integer or a floating point number.</p>
<p>A period is an interval in seconds specified as a rational constant.</p>
<p>The following code defines a duration of ten milliseconds and prints out the number of periods in the duration.</p>
<p>[code light="true" language="cpp"]<br />
//1/1000<br />
using Milli = ratio&lt;INTMAX_C(1), INTMAX_C(1000)&gt;;<br />
using Milliseconds = duration&lt;intmax_t, Milli&gt;;<br />
//declare a duration of 10 periods where each period is equal<br />
//to 1/1000 seconds i.e. ten milliseconds<br />
Milliseconds ms(10);<br />
//print the number of periods (ticks) in the duration instance<br />
cout &lt;&lt; ms.count() &lt;&lt; endl;<br />
[/code]</p>
<p>The <code>intmax_t</code> type is the integer type that can represent the biggest possible signed integer.</p>
<p><code>INTMAX_C</code> is a macro that converts the integer constant to the <code>intmax_t</code> type.</p>
<p>It is possible to use floating point values as the type that represents the number of tick counts as well.</p>
<p>You convert between durations with different representations and period types by means of the <code>duration_cast</code> function.</p>
<p>A duration can be converted to a duration with a different tick period only if the number of ticks is represented as a floating point number.</p>
<p>To detect if a tick count representation is a floating point type you use the <code>treat_as_floating_point</code> type trait:</p>
<p>[code lang="cpp" light="true"]<br />
using FloatNano = duration&lt; double, nanoseconds &gt;;<br />
//check if floating point<br />
static_assert(<br />
  treat_as_floating_point&lt; FloatNano::rep &gt;::value,<br />
  &quot;Duration representation must be a floating point type&amp;amp;amp&quot;);</p>
<p>//if we get here it means the duration tick count type is<br />
//a floating point type<br />
FloatNano fd(500.0);<br />
auto d = duration_cast&lt;milliseconds&gt;(fd); //0.0005 ms<br />
[/code]</p>
<p>The minimum, maximum and zero representation for a specific tick count type are returned by the <code>min()</code>, <code>max()</code> and <code>zero()</code> static methods found in the <code>duration_values</code> type.</p>
<h2>Time point</h2>
<p>The <code>time_point</code> type is the representation of a point in time and it is parametrized on the clock and duration types.</p>
<p>The reason for which the <code>time_point</code> type is dependent on the clock type is because the time point represents the number of periods (ticks) elapsed from the beginning of time and such <em>beginning</em> changes depending on the clock type: it could be e.g. the start of the current process or a specific point in physical time.</p>
<p>The dependency on the duration type is required because the <code>time_point</code> type is implemented as a duration representing the elapsed time since the beginning of time.<br />
Such duration is returned by the <code>time_since_epoch()</code> member. The default duration type is the duration type declared in the clock type.</p>
<p>You convert between time points with different durations with the <code>time_point_cast</code> function.</p>
<p>To convert a <code>time_point</code> to a standard <code>time_t</code> type use the static member function <code>to_time()</code> found in the clock type.</p>
<p>To print a time point you use the <code>put_time()</code> library function. Note however that at the time of this writing the only compiler shipping with a complete C++11 library implementation is CLang so you might not find such function in your C++ library.</p>
<p>In case <code>put_time()</code> is not available you can still easily print a <code>time_point</code> instance by first converting it to <code>time_t</code>:</p>
<p>[code lang="cpp" light="true"]<br />
#include &lt;chrono&gt;<br />
#include &lt;ctime&gt;<br />
...<br />
using Clock = std::chrono::system_clock;<br />
std::time_t now = Clock::to_time_t(Clock::now());<br />
cout &lt;&lt; std::ctime(now) &lt;&lt; endl;<br />
[/code]</p>
<h2>Clock</h2>
<p>The clock type returns the <code>time_point</code> instance representing the current time whenever its static <code>now()</code> method is invoked.</p>
<p>The three clock types required to be available in C++11 STL implementations are:</p>
<ul>
<li><code>system_clock</code>: tracks physical wall clock time; invoking <code>now()</code> on this clock at two different times does not guarantee that the second call to <code>now()</code> returns a time greater than the previous call to <code>now()</code></li>
<li><code>steady_clock</code>: monotonic time function, the time returned by <code>now()</code> is always increasing</li>
<li><code>high_resolution_clock</code>: smallest possible period</li>
</ul>
<p>On many systems the resolution period is one nanosecond for all clock types.</p>
<p>You have actually already seen all you need to know about clock usage in the previous section i.e. how to call the <code>now()</code> and <code>to_time_t()</code> static methods.</p>
<p>Now let's look at some properties unique to each clock type.</p>
<p>The properties that identify a specific clock type are:</p>
<ul>
<li>period</li>
<li>origin of time</li>
<li>steadiness</li>
</ul>
<p>The following code shows how to retrieve and print the above information given a clock type:</p>
<p>[code lang="cpp" light="true"]<br />
using Clock = std::chrono::system_clock;<br />
using TimePoint = Clock::time_point;<br />
const bool isSteady = Clock::is_steady;<br />
//one period (tick) is equal to num/den seconds<br />
const intmax_t periodNum = Clock::period::num;<br />
const intmax_t periodDen = Clock::period::den;</p>
<p>//the default constructor for a time_point initializes<br />
//it to the origin of time<br />
std::time_t epoch = Clock::to_time_t(TimePoint());<br />
[/code]</p>
<h2>Timing execution</h2>
<p>You now have all the information required to easily time your own code.</p>
<p>For timing execution do use a clock which has an <code>is_steady</code> member set to true e.g. <code>steady_clock</code>.</p>
<p>[code lang="cpp" light="true"]<br />
using namespace std;<br />
using namespace chrono;<br />
using Timer = steady_clock;<br />
using Time = Timer::time_point;<br />
using Duration = Timer::duration;<br />
using ms = ratio&lt; INTMAX_C(1), INTMAX_C(1000) &gt;;<br />
auto Tick = []{ return Timer::now(); };</p>
<p>const Time begin = Tick();<br />
//execute code<br />
...<br />
const Time end = Tick();<br />
const Duration elapsed = end - begin;<br />
cout &lt;&lt; &quot;Elapsed time: &quot;<br />
     &lt;&lt; duration_cast&lt; duration&lt; intmax_t, ms &gt; &gt;(elapsed)<br />
     &lt;&lt; &quot;ms&quot; &lt;&lt; endl;<br />
[/code]</p>
<p>Instead of your own <code>ratio</code> constant you can use the predefined constants: <code>milli</code>, <code>micro</code>, ...</p>
<p>Instead of your own <code>duration</code> constant you can use the predefined constants: <code>milliseconds</code>, <code>microseconds</code>, ...</p>
<p>e.g.:</p>
<p>[code lang="cpp" light="true"]<br />
...<br />
//use std::chrono::milliseconds duration type<br />
cout &lt;&lt; duration_cast&lt; milliseconds &gt;(elapsed).count() &lt;&lt; endl;<br />
...<br />
[/code]</p>
<p>Checkout the ISO standard, <em>cppreference</em> or your own STL documentation for a complete list of such constants.</p>
<h2>Code</h2>
<p>Sample code showing the use of the various <code>chrono</code> types:<br />
<a title="time-1.cpp" href="https://github.com/ugovaretto/cpp11-scratch/blob/master/training/time-1.cpp">Sample code</a></p>
<p>A minimal implementation of a C++11 compliant timer class:<br />
<a title="timer" href="https://github.com/ugovaretto/cpp11-scratch/tree/master/training/timer">Timer</a></p>
