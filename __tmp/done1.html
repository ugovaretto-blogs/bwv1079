---
layout: post
title: C++11 & task based concurrency - part 1
date: 2013-11-20 16:11:29.000000000 +08:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- C++
- c++11
- Concurrency
tags:
- c++
- concurrency
- multithreading
meta:
  _edit_last: '58138826'
  _publicize_pending: '1'
  _oembed_0e7201a9f62d97e53855c0e33a2d8c4c: "{{unknown}}"
author:
  login: ugovaretto
  email: ugovaretto@gmail.com
  display_name: ugovaretto
  first_name: ''
  last_name: ''
permalink: "/2013/11/20/c11-task-based-concurrency-part-1/"
---
<p>Task-based concurrency refers to the action of scheduling a number of tasks for execution and have a number of execution paths (threads) run concurrently to execute the tasks.</p>
<p>Task-based concurrency is not built into C++11 implementations since it is not part of the standard which I believe makes a lot of sense: I do not think it is possible to easily specify a task-based solution generic enough which makes sense to "standardize".</p>
<p>I'm personally never happy with the various solutions offered by e.g. TBB or OpenMP, since I want/need to deal with things like:</p>
<ul>
<li>dynamic parallelism (change the number of parallel executing threads as you go)</li>
<li>dynamic task mapping: change the number of tasks assigned to a signle thread at run-time</li>
<li>logging: have threads log the parameters and results passed to them automatically without having to explicitly write logging code in the thread body</li>
<li>hybrid architectures: need to synchronize CPU threads with parallel execution on accelerators</li>
<li>shared cache/memoization: what if I want to intercept the parameters passed to a callable object scheduled for execution, use the parameters as a key and return a pre-computed value if available ?</li>
<li>parallelization strategy:
<ul>
<li>single shared task queue</li>
<li>multiple shared task queues load balanced with round robin</li>
<li>one data queue per thread with work stealing</li>
<li>...</li>
</ul>
</li>
</ul>
<p>As you will see in the second part of this post where I show a possible implementation for a task executor, creating your own solution with the new C++11 facilities is actually pretty straightforward.</p>
<h1>A crash course on C++ 11 concurrency</h1>
<p>I am introducing here the bare minimum amount of concepts required to understand the second part the article, a short list of resources useful for learning about parallel programming with C++ is presented at the end of this post.</p>
<h2>Let's do it together</h2>
<p>When you need to solve a problem through computation on machines with multiple processing units (cores) it <em>might</em> be useful to split execution into multiple tasks to be executed in parallel to cooperatively carry on the computation.</p>
<p>One way of having multiple concurrent execution paths is to create threads.</p>
<p>Threads are concurrent execution paths created from within a process (a computer program being executed); the process itself runs inside a thread which is created when the process starts.</p>
<p>Tasks can be mapped to threads:</p>
<ol>
<li>one to one: one task is executed by exactly one thread</li>
<li>many to one: multiple tasks are executed sequentially by a single thread</li>
</ol>
<p>(1) implements thread-level concurrency, directly supported by C++ 11 and (2) implements task-based concurrency, not supported by C++ 11.</p>
<p>Note however that task-based concurrency is anyway supported at the operating system level: if you create more active threads than CPU cores the operating system will need to have multiple logical threads (created by user code) executed by a single hardware thread. And the operating system might indeed be very good at that by the way, so in some cases you might decide to just map one task to a single thread regardless of the number of threads you create.</p>
<h3>C++11 threads</h3>
<p>In C++ 11 threads are created through the <code>std::thread</code> object which accepts in its constructor the callable object (function, function object...) to execute together with the parameters to pass to it.</p>
<p>In the rest of the article I use the term <em>parent thread</em> to identify a thread which creates other threads and the term <em>child thread</em> to describe threads created by a <em>parent thread</em>.</p>
<p>In order to retrieve the results computed by child threads we need the child threads to write data into a buffer shared with the parent thread.</p>
<p>The parent thread will then have to wait until all of its child threads join the main thread, i.e. finish execution, and then read the results from the shared buffer(s).</p>
<p>The solution works provided the threads do indeed finish execution but what if the threads retrieve and process data from a queue in a loop ?</p>
<p>In this case you need a way to be notified each time data is available while the threads are still running; also when you read the data you have to somehow protect the buffer you read from so that while a thread reads from the memory buffer other thread cannot access it for writing.</p>
<p>One way of dealing with this scenario is to wait until a result is available then lock somehow the memory region you want to read from and perform the read operation; in this case it is important to treat the wait-read sequence as an atomic operation so that when you are notified that data is available the memory region is already locked; the flow looks like:</p>
<ul>
<li><code>start thread</code></li>
<li><code>wait and acquire lock when notified</code></li>
<li><code>read data</code></li>
</ul>
<p>Provided you implement <strong>correclty</strong> all the required logic you still have one problem: exceptions.</p>
<p>If a thread throws an exception how do you forward it to the parent thread ?</p>
<p>You can think of using one shared buffer per thread to store exceptions, then check if an exception was raised once you are notified by the child thread.</p>
<p>Implementing also the exception handling part adds additional complexity to an already complex problem, so let's look at another solution which happens to be readily available in C++ 11.</p>
<h2>Promise me you'll remember</h2>
<p>Another way to pass results from child threads to the parent thread is through some form of object which acts as a messenger between the child (created) thread and the parent (creator) thread.</p>
<p>The child thread tells the messenger to dispatch the result to the parent thread once the result is ready.</p>
<p>The parent thread retrieves the result from a mailbox provided by the messenger object at the messenger creation time, in case the result is not available the parent thread is automatically put into the wait state until the message is delivered to the mailbox.</p>
<p>In pseudo-code:</p>
<p>[code lang="cpp" light="true"]<br />
Search(start, end, messenger) {<br />
...</p>
<p>  messenger.Send(index_of_found_text);<br />
}<br />
...<br />
Messenger messenger1;<br />
Messenger messenger2;<br />
Mailbox mailbox1 = messenger1.mailbox();<br />
Mailbox mailbox2 = messenger2.mailbox();</p>
<p>Thread search_1st_half = Thread(Search,<br />
                                start,<br />
                                start + half_text_length<br />
                                messenger1);<br />
Thread search_2nd_half = Thread(Search,<br />
                                start + half_text_length,<br />
                                start + full_text_length,<br />
                                messenger2);   </p>
<p>Index text_index_1st_half = mailbox1.Recv();<br />
Index text_index_2nd_half = mailbox2.Recv();</p>
<p>if(valid(text_index_1st_half)) report(valid_index_1st_half);<br />
else if(valid(text_index_1st_half)) report(valid_index_2nd_half);<br />
else report(&quot;NOT FOUND&quot;);<br />
...<br />
[/code]</p>
<p>You need two objects, <em>Messenger</em> and <em>Mailbox</em>, because they are accessed from two separate threads: <em>Messenger</em> is accessed by the child thread and <em>Mailbox</em> by the parent thread.</p>
<p>Now, what if on top of the shown functionality the <em>Messenger</em> object also had a way to forward exceptions from child to parent thread ?</p>
<p>That would be great and that's exactly what C++ 11 allows you to do.</p>
<p>The messenger is an <code>std::promise</code>, which represents a promise to perform a computation and the mailbox is an <code>std::future</code> which represents a value that will be available in the future.</p>
<p>Nice, but how do we signal an error without throwing an exception ?</p>
<p>You could return a composite data type with two members: * a valid/invalid flag * the actual return value</p>
<p>C++14 was supposed to support such a case through the <code>std::optional</code> type but it was voted out of the standard and moved to a separate technical report; <code>boost::optional</code> is available though.</p>
<h2>Task-based concurrency - take 1</h2>
<p>We have seen what threads look like, now let's look at a simple way to perform task based concurrency.</p>
<p>One easy way to have a pre-defined number of threads execute tasks is to launch the same number of threads multiple times and wait for completion until all tasks have been executed.</p>
<p>In the following example a <em>task</em> is represented by the execution of the function <em>f</em>: we execute the function <em>f</em> <code>num_tasks</code> times with <code>num_threads</code> threads running concurrently.</p>
<p>[code lang="cpp" light="true"]<br />
for(int t = 0; t != num_tasks; t += num_threads) {<br />
  ThreadArray ta;<br />
  for(int i = 0; i != num_threads; ++i) {<br />
    t.push_back(Thread(f, data, t + i)); //calls f(data t + i)<br />
  }<br />
  //join all threads before continuing to the next batch of tasks<br />
  barrier(ta.begin(), ta.end()); //call .join() method on each thread<br />
}<br />
[/code]</p>
<p>This works if all the threads execute only once; one of the drawbacks is that instead of creating the threads once and reusing them, new threads are created at each iteration.</p>
<h2>Stop and go</h2>
<p>To have a fixed number of pre-created threads perform all the computation you need:</p>
<ol>
<li>create the threads</li>
<li>put the threads in a wait state</li>
<li>add tasks to a shared queue and wake up the threads</li>
<li>have the threads retrieve and execute tasks in the queue and go back to (2)</li>
</ol>
<p>The queue itself can be a single queue shared by all the threads</p>
<p>You also need to have a way to send a termination request to the threads, should they need to be terminated before the process exists, which they always do unless you want to exit the process with a number of threads still in execution which results in a call to <code>abort()</code>.</p>
<p>If all you want is to get rid of the error just override the default termination handler with your own:</p>
<p>[code lang="cpp" light="true"]<br />
void quiet_termination() { exit(0); }</p>
<p>int main(int argc, char** argv) {<br />
    std::set_terminate(quiet_termination);<br />
...<br />
}<br />
[/code]</p>
<p>One way of gracefully terminating threads running a wait-get-execute loop is to insert data (e.g. an empty task) recognized as a termination condition in the execution queue.</p>
<h2>References</h2>
<p>Disclaimer: the first reference is to the official ISO C++ 11 standard document, if you can, do have a look at it; all the threading feautures are well described and in some cases easier to understand than on various online resources, and sample code is provided as well.</p>
<ul>
<li>ISO, IEC 14882-2011 C++, chapter 30: <code>http://isocpp.org/std/the-standard</code></li>
<li><a href="http://en.cppreference.com/w/">cppreference</a></li>
<li>Anthony Williams, <em>C++ Concurrency in Action</em> - Manning Publications</li>
<li><a href="http://bartoszmilewski.com/category/concurrency/">Bartoz Milewzki's blog</a></li>
<li><a href="http://www.youtube.com/playlist?list=PL1835A90FC78FF8BE&amp;feature=c4-feed-u">Bartoz Milewzki's C++ concurrency videos</a></li>
<li><a href="http://herbsutter.com/category/concurrency">Herb Sutter blog on concurrency</a></li>
<li><a href="http://scottmeyers.blogspot.ch/search?q=future">Scott Meyers on std::future</a></li>
<li>Not available yet at this time (October 2013), scheduled for Q2 2014: Scott Meyers'<em>Effective C++11/14</em>, track the developments on his website (<code>www.aristeia.com</code>)</li>
</ul>
